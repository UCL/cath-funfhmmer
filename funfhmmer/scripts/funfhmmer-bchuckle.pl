#!/usr/bin/env perl
use strict;
use warnings;
use List::Util qw( min max );
use File::Copy;

#####################################################################################################################################################
#
# 							FunFHMMer code by Sayoni
#
# This perl script takes in a folder containing starting clusters of a
# particular CATH Superfamily (generated by GEMMA clustering) and the 
# corresponding clustering trace file to generate FunFHMMer families 
# for the CATH Superfamily
##
#  + Using the 1st quartile Q1 (25% of the Evalues in trace) as the Evalue threshold for auto-merging and Q3 for Evalue relaxing during merging
#  + Filter fragments after every merge, so that no coln. is relaxed. - let it be 80% of the threshold
#  + Added check that if an aln is found empty at any point, the sf tries to redo the alignment
#  + Added checks such that when a superfamily starts running again, it doesnt calculate GS/make alignments that is already done
#####################################################################################################################################################

if ( scalar @ARGV != 5 ) {
	die
"Usage $0 <CATH_superfamily_code> <Evalue_threshold_q1> <Evalue_threshold_q3> <base_dir>\n";
}

our $superfamily = $ARGV[0];
chomp($superfamily);
our $evalthresh_q1 = $ARGV[1];
chomp($evalthresh_q1);
our $evalthresh_q3 = $ARGV[2];
chomp($evalthresh_q3);
our $base_dir = $ARGV[3];
chomp($base_dir);
our $wd = $ARGV[4];
chomp($wd);

# Specify the required directory paths
#FUNFAMS dir
our $target_sup_cluster_dir = "$wd/$superfamily";
our $dir = $target_sup_cluster_dir; 
#SCRIPT dir
our $codes_dir = "$base_dir/bin";
#TRACE dir
our $tracedir = "$wd/$superfamily";
#RUNLOG dir
our $logdir = "$wd/$superfamily";

our $t = localtime();
# start a funfhmmer running LOG

my $logfile ="$logdir/$superfamily.LOG";
open(OUT, ">$logfile") or die "Can't open file $logfile\n";
$t = localtime();
print OUT "[$t] #$superfamily: #starting FunFHMMer protocol\n";
$t = localtime();
print OUT "[$t] #$superfamily\tEvalue-Q1:$evalthresh_q1\tEvalue-Q3:$evalthresh_q3\n";

# start a cluster comparison/merging LOG

my $mergelog ="$logdir/$superfamily.mergelog";
open(MERGES, ">$mergelog") or die "Can't open file $mergelog\n";

# specify superfamily clustering trace file path
my $trace_file = "$tracedir/$superfamily.trace";
if(! -e $trace_file){
	$t = localtime();
	print "[$t] #ERROR: $trace_file NOT found: $!\n";
	print OUT "[$t] #ERROR: $trace_file NOT found: $!";
	exit;
	&redo_superfamily($superfamily);
}

# filter starting clusters of any fragment sequences
# - sequences  should have length of at least 80% of the avg. sequence length of the cluster
$t = localtime();
print OUT "[$t] #$superfamily: started filtering sequences in starting clusters\n";
&filter_mfasta_by_seq_length_startingclusters();
$t = localtime();
print OUT "[$t] #$superfamily: filtering completed\n";

# make subfolder "xtra" if it does not exist
# this folder would contain the GroupSim (GS) files for all cluster comparisons

our $xtra = "$dir/xtra";
unless(-e "$xtra"){
	mkdir($xtra);
}

# declare variables used in the script
my $start_run = time(); 
my (@cols, @merges); my %not_merged_list = (); my %not_merged_ignorenextones =();
my ($c1,$c2,$p,$e,$c1_path,$c1_seqs,$c2_path,$c2_seqs,$line); my $c1_dops; my $c2_dops; our $cd = "cd"; 
my $cl1_dops; my $cl2_dops; my ($cl1,$cl2); my $evalue; my $signal1; my $signal2; my $reason1; my $reason2; my ($signal,$reason);
my @gs_score; my @gs_score1; my @gs_score2;my $count=0; our $aln="aln"; our $faa="faa"; our $dops = "dops"; our $clstr = "clstr";

# open trace file 
# -split each line into numbers separated by tab and store in @cols & store each @col in array of arrays: @merges		

open my $FCF, "<$trace_file";
while (<$FCF>){
	chomp;
	@cols = split (/\t/, $_); 						
	push @merges, [@cols];				
	}
close $FCF;

# for each cluster merging in the trace file in order
foreach (@merges){	
	
	($c1, $c2, $p, $e) = @{$_}; 
	
	# get the e-value power number and print current merging cluster info   
	$e=~ /\d\.\d*\w\+*(\-*\d*)/;
	$evalue=$e;
	$t = localtime();
	print OUT "[$t] $c1\t&\t$c2\t-->\t$p\t@ $e\t";
	print MERGES "$c1\t&\t$c2\t->\t$p\t$e\t";
	
	# check IF any cluster was not produced by previous merging
	if (%not_merged_list){
		
	 	# IF both clusters not_merged b4
	 	if ($not_merged_list{$c1} && $not_merged_list{$c2}){

			print OUT "Wont merge, None merged b4\n";
			print MERGES "Wont merge, None merged b4\n";
			# add them into not_merged list
			$not_merged_list{$p} = [$c1,$c2]; 
			$not_merged_ignorenextones{$p} = [$c1,$c2];
			next;
		}
		# IF either of the clusters not_merged b4
		elsif ($not_merged_ignorenextones{$c1} || $not_merged_ignorenextones{$c2}){

		print OUT "Wont merge, None merged b4\n";
		print MERGES "Wont merge, None merged b4\n";
			# IF .faa exists
			if (-e "$dir/$c1.$faa"){ 
				$c1_path="$dir/$c1.$faa"; 
				$c1_seqs= `grep -c '>' $c1_path`;
				
				# IF cluster has 1 seq, rename .faa to .aln
				if($c1_seqs ==1){   
					rename ("$dir/$c1.$faa","$dir/$c1.$aln");
					}
				# IF cluster has multiple seqs., align the cluster seqs., delete .faa
				else {
					&align($c1,$c1_seqs);
					unlink("$dir/$c1.$faa");
					}
				}
			# same for the other cluster
			if (-e "$dir/$c2.$faa"){ 
				$c2_path="$dir/$c2.$faa";
				$c2_seqs= `grep -c '>' $c2_path`;
				if($c2_seqs ==1){   
					rename ("$dir/$c2.$faa","$dir/$c2.$aln");
					}
				else{
					&align($c2,$c2_seqs);
					unlink("$dir/$c2.$faa");
					}
				}
			# add them into not_merged list
			$not_merged_ignorenextones{$p} = [$c1,$c2];
			next;
		}
		# IF both the clusters not_merged b4 at all
		elsif ($not_merged_ignorenextones{$c1} && $not_merged_ignorenextones{$c2}){
				
			print OUT "Wont merge as None merged b4\n";
			print MERGES "Wont merge as None merged b4\n";
			# do same, as for the previous clusters
			if (-e "$dir/$c1.$faa"){ 
				$c1_path="$dir/$c1.$faa"; 
				$c1_seqs= `grep -c '>' $c1_path`;
				if($c1_seqs ==1){   
					rename ("$dir/$c1.$faa","$dir/$c1.$aln");
					}
				else {
					&align($c1,$c1_seqs);
					unlink("$dir/$c1.$faa");
					}
			}
			if (-e "$dir/$c2.$faa"){ 
				$c2_path="$dir/$c2.$faa";
				$c2_seqs= `grep -c '>' $c2_path`;
				if($c2_seqs ==1){   
					rename ("$dir/$c2.$faa","$dir/$c2.$aln");
					}
				else{
					&align($c2,$c2_seqs);
					unlink("$dir/$c2.$faa");
					}
				}
		# add them into not_merged list
		$not_merged_ignorenextones{$p} = [$c1,$c2];
		next;
		}
		
	# IF c2 was not_merged b4, find its predessors and check c1 merging with either of them or both
	elsif ($not_merged_list{$c2}) {
	
		# get c2's 2 unmerged cluster compositions
		$cl1 = $not_merged_list{$c2}[0]; 				
		$cl2 = $not_merged_list{$c2}[1];
		
		#get dops score of MSA using scorecons program
		&scorecons($cl1); 
		&scorecons($cl2);
		
		#IF dops file is empty, assign dops_score=0, else read score from the file
		$cl1_dops = (-z "$dir/xtra/$cl1.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$cl1.$aln.$dops"; <> }; 
		$cl2_dops = (-z "$dir/xtra/$cl2.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$cl2.$aln.$dops"; <> }; 
		
		# IF .faa, change to .aln as b4
		if (-e "$dir/$c1.$faa"){ 
			$c1_path="$dir/$c1.$faa"; 
			$c1_seqs= `grep -c '>' $c1_path`;
			if($c1_seqs ==1){   
				rename ("$dir/$c1.$faa","$dir/$c1.$aln");
				}
			else {
				&align($c1,$c1_seqs);
				unlink("$dir/$c1.$faa");
				}
			}
		$c1_path="$dir/$c1.$aln"; 
		unless(-e "$dir/xtra/$c1.$aln.$dops"){
			&scorecons($c1);
			}
		@gs_score1 = (); @gs_score2 = ();
		$c1_dops = (-z "$dir/xtra/$c1.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$c1.$aln.$dops"; <> }; 
		
		# Get Groupsim_scores for both merging and compare and then decide
		@gs_score1 = ($cl1_dops > $c1_dops) ? &gs_process($cl1,$c1) : &gs_process($c1,$cl1);

		if($evalue<$evalthresh_q1){
			($signal1,$reason1)= ($cl1_dops>70 || $c1_dops>70) ? &scoreanalysis(@gs_score1) : &scoreanalysis_dops_low(@gs_score1);
			}
		elsif($evalue>=$evalthresh_q1 && $evalue<$evalthresh_q3){
			($signal1,$reason1)= ($cl1_dops>70 || $c1_dops>70) ? &scoreanalysis_none_chk_incl(@gs_score1) : &scoreanalysis_dops_low(@gs_score1);
			}
		elsif($evalue>=$evalthresh_q3){
			($signal1,$reason1)= ($cl1_dops>70 || $c1_dops>70) ? &scoreanalysis_none_chk_incl_strict(@gs_score1) : &scoreanalysis_dops_low(@gs_score1);
			}
		# Use Cluster with higher dops as ref. or 1st group always!
		@gs_score2 = ($cl2_dops > $c1_dops) ? &gs_process($cl2,$c1) : &gs_process($c1,$cl2);

		if($evalue<$evalthresh_q1){
			($signal2,$reason2)= ($cl2_dops>70 || $c1_dops>70) ? &scoreanalysis(@gs_score2) : &scoreanalysis_dops_low(@gs_score2);
			}
		elsif($evalue>=$evalthresh_q1 && $evalue<$evalthresh_q3){
			($signal2,$reason2)= ($cl2_dops>70 || $c1_dops>70) ? &scoreanalysis_none_chk_incl(@gs_score2) : &scoreanalysis_dops_low(@gs_score2);
			}
		elsif($evalue>=$evalthresh_q3){
			($signal2,$reason2)= ($cl2_dops>70 || $c1_dops>70) ? &scoreanalysis_none_chk_incl_strict(@gs_score2) : &scoreanalysis_dops_low(@gs_score2);
			}
		
		if($signal1==1 && $signal2==1){ 
			# Merge c1 & cl1 & cl2
			print OUT "Merge, $c1 & $cl1 , $cl2 --> $p\n";
			print MERGES "Merge\t$c1\t$cl1\t$cl2\t->\t$p\n";
			&merge_gs_3($c1,$cl1,$cl2,$p);
			next;
			}	
		elsif($signal1==1 && $signal2==0){ 
			# Merge c1 &cl1
			print OUT "Merge, $c1 & $cl1 --> $p\n";
			print MERGES "Merge\t$c1\t$cl1\t->\t$p\n";
			&merge_gs($c1,$cl1,$p); 
			next;
			}
		elsif($signal1==0 && $signal2==1){ 
			# Merge c1 &cl2
			print OUT "Merge, $c1 & $cl2 --> $p\n";
			print MERGES "Merge\t$c1\t$cl2\t->\t$p\n";
			&merge_gs($c1,$cl2,$p);
			next;
			}
		else{ 
			# dont Merge c1 & cl1 & cl2
			print OUT "Wont merge $c1 & $cl1,$cl2\n";
			print MERGES "Wont merge $c1\t$cl1\t$cl2\n";
			$not_merged_list{$p} = [$c1,$cl1,$cl2]; 
			next;
			}
	}
	
	# IF c1 was not_merged b4, find its predessors and check c2 merging with either of them or both
	elsif ($not_merged_list{$c1}) { 						
		# get c1's 2 unmerged cluster compositions
		$cl1 = $not_merged_list{$c1}[0]; 				
		$cl2 = $not_merged_list{$c1}[1];
		&scorecons($cl1);
		&scorecons($cl2);
		$cl1_dops = (-z "$dir/xtra/$cl1.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$cl1.$aln.$dops"; <> }; 
		$cl2_dops = (-z "$dir/xtra/$cl2.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$cl2.$aln.$dops"; <> }; 
		if (-e "$dir/$c2.$faa"){ 
			$c2_path="$dir/$c2.$faa";
			$c2_seqs= `grep -c '>' $c2_path`;
			if($c2_seqs ==1){   
				rename ("$dir/$c2.$faa","$dir/$c2.$aln");
				}
			else{
				&align($c2,$c2_seqs);
				unlink("$dir/$c2.$faa");
				}
			}
		$c2_path="$dir/$c2.$aln";
		unless(-e "$dir/xtra/$c2.$aln.$dops"){
			&scorecons($c2);
			}
		@gs_score1 =(); @gs_score2 =();
		$c2_path="$dir/$c2.$aln";
		
		$c2_dops = (-z "$dir/xtra/$c2.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$c2.$aln.$dops"; <> }; 
		$e=~ /\d\.\d*\w(\-\d*)/;
		 $evalue=$e;

		# Get score files for both merging and compare and then decide 		
		# Use Cluster with higher dops as ref. or 1st group always!
		@gs_score1 = ($cl1_dops > $c2_dops) ? &gs_process($cl1,$c2) : &gs_process($c2,$cl1);
		
		if($evalue<$evalthresh_q1){
			($signal1,$reason1)= ($cl1_dops>70 || $c2_dops>70) ? &scoreanalysis(@gs_score1) : &scoreanalysis_dops_low(@gs_score1);
			}
		elsif($evalue>=$evalthresh_q1 && $evalue<$evalthresh_q3){
			($signal1,$reason1)= ($cl1_dops>70 || $c2_dops>70) ? &scoreanalysis_none_chk_incl(@gs_score1) : &scoreanalysis_dops_low(@gs_score1);
			}
		elsif($evalue>= $evalthresh_q3){
			($signal1,$reason1)= ($cl1_dops>70 || $c2_dops>70) ? &scoreanalysis_none_chk_incl_strict(@gs_score1) : &scoreanalysis_dops_low(@gs_score1);
			}
			
			
		# Use Cluster with higher dops as ref. or 1st group always!
		@gs_score2 = ($cl2_dops > $c2_dops) ? &gs_process($cl2,$c2) : &gs_process($c2,$cl2);

		if($evalue < $evalthresh_q1){
			($signal2,$reason2)= ($cl2_dops>70 || $c2_dops>70) ? &scoreanalysis(@gs_score2) : &scoreanalysis_dops_low(@gs_score2);
			}
		elsif($evalue>= $evalthresh_q1 && $evalue< $evalthresh_q3){
			($signal2,$reason2)= ($cl2_dops>70 || $c2_dops>70) ? &scoreanalysis_none_chk_incl(@gs_score2) : &scoreanalysis_dops_low(@gs_score2);
			}
		elsif($evalue>= $evalthresh_q3){
			($signal2,$reason2)= ($cl2_dops>70 || $c2_dops>70) ? &scoreanalysis_none_chk_incl_strict(@gs_score2) : &scoreanalysis_dops_low(@gs_score2);
			}
		
		if($signal1==1 && $signal2==1){ 
			# Merge c2 & cl1 & cl2
			print OUT "Merge, $c2 & $cl1 , $cl2 --> $p\n";
			print MERGES "Merge\t$c2\t$cl1\t$cl2\t->\t$p\n";
			&merge_gs_3($c2,$cl1,$cl2,$p);
			next;
			}	
		elsif($signal1==1 && $signal2==0){ 
			# Merge c2 &cl1
			print OUT "Merge, $c2 & $cl1 --> $p\n";
			print MERGES "Merge\t$c2\t$cl1\t->\t$p\n";
			&merge_gs($c2,$cl1,$p); 
 			next;
			}
		elsif($signal1==0 && $signal2==1){ 
			# Merge c2 &cl2
			print OUT "Merge, $c2 & $cl2 --> $p\n";
			print MERGES "Merge\t$c2\t$cl2\t->\t$p\n";
			&merge_gs($c2,$cl2,$p);
			next;
			}
		else{ 
			# dont Merge c2 & cl1 & cl2
			print OUT "Wont merge $c2 & $cl1,$cl2\n";
			print MERGES "Wont merge $c2\t$cl1\t$cl2\n";
			$not_merged_list{$p} = [$c2,$cl1,$cl2]; 
			next;
			}
	}
	}

	@gs_score = ();
	
########### NORMAL ##########################
		
		if (-e "$dir/$c1.$faa"){ 
		$c1_path="$dir/$c1.$faa"; 
		$c1_seqs= `grep -c '>' $c1_path`;
		if($c1_seqs ==1){   
			rename ("$dir/$c1.$faa","$dir/$c1.$aln");
			}
		else {
			&align($c1,$c1_seqs);
			unlink("$dir/$c1.$faa");
			}
		}
	$c1_path="$dir/$c1.$aln"; 
	if (-e "$dir/$c2.$faa"){ 
		$c2_path="$dir/$c2.$faa";
		$c2_seqs= `grep -c '>' $c2_path`;
		if($c2_seqs ==1){   
			rename ("$dir/$c2.$faa","$dir/$c2.$aln");
			}
		else{
			&align($c2,$c2_seqs);
			unlink("$dir/$c2.$faa");
			}
		}
	$c2_path="$dir/$c2.$aln";
	
	# Merge as usual from lowest evalue to evaluethresh (1st quartile of evalue range)
	if($evalue < $evalthresh_q1){ 
		print OUT "Merge, e < $evalthresh_q1\n";
		print MERGES "Merge, e < $evalthresh_q1\n";
		&merge_non_gs($c1,$c2,$p);
		next;
		}
		
	# For higher Evalues, we need to calculate additional things - mda_score and 70 of the clusters: 
	# Get dops of the clusters to check MSA of clusters are informative enough - choose GS score analysis method accordingly
	unless(-e "$dir/xtra/$c2.$aln.$dops"){
		&scorecons($c2);
		}
	unless(-e "$dir/xtra/$c1.$aln.$dops"){ 
		&scorecons($c1);
		}
	$c1_dops = (-z "$dir/xtra/$c1.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$c1.$aln.$dops"; <> }; 
	$c2_dops = (-z "$dir/xtra/$c2.$aln.$dops") ? "0.000" : do { local $/; local @ARGV = "$dir/xtra/$c2.$aln.$dops"; <> }; 
	
	# Evalue from -50 to -20
	print OUT "GS ->  ";
	print MERGES "GS ->  ";
    if(($c1_dops>=70 || $c2_dops>=70) && $evalue >= $evalthresh_q1 && $evalue <= $evalthresh_q3){ 	
		# Use Cluster with higher dops as ref. or 1st group always!		
		@gs_score = ($c1_dops > $c2_dops) ? &gs_process($c1,$c2) : &gs_process($c2,$c1);				
		($signal,$reason)=&scoreanalysis_none_chk_incl(@gs_score);	
		# Analyze score signals 
		if($signal==1){
			# Merge
			#print "Merge\n";
			print OUT "Merge\n";
			print MERGES "Merge\n";
			&merge_gs($c1,$c2,$p);
			}
		else{
			# Split
			#print"Wont Merge, $reason\n"; 
			print OUT "Wont Merge, $reason\n";
			print MERGES "Wont Merge, $reason\n";
			$not_merged_list{$p} = [$c1,$c2];
			}
		next;
	}
	
    # Evalue from eg -50 to -20, Use Cluster with higher dops as ref. or 1st group always!
	elsif(($c1_dops<70 || $c2_dops<70) && $evalue >= $evalthresh_q1 && $evalue < $evalthresh_q3){ 									
		@gs_score = ($c1_dops > $c2_dops) ? &gs_process($c1,$c2) : &gs_process($c2,$c1);
			($signal,$reason)=&scoreanalysis_none_chk_incl(@gs_score);
			
		# Analyze score signals 
 		if($signal==1){
 			# Merge
			print OUT "Merge\n";
			print MERGES "Merge\n";
			&merge_gs($c1,$c2,$p);
			}
		else{ 
			#Split
			print OUT "Wont Merge, $reason\n";
			print MERGES "Wont Merge, $reason\n";
			$not_merged_list{$p} = [$c1,$c2];
			}
		next;
	}
	# Evalue from -20 to 0, Use Cluster with higher dops as ref. or 1st group always!
	elsif($evalue >= $evalthresh_q3){ 										
		@gs_score = ($c1_dops > $c2_dops) ? &gs_process($c1,$c2) : &gs_process($c2,$c1);
		($signal,$reason)=&scoreanalysis_none_chk_incl_strict(@gs_score);
		# Analyze score signals 												
 		if($signal==1){	
 			# Merge												
			print OUT "Merge\n";
			print MERGES "Merge\n";
			&merge_gs($c1,$c2,$p);
			}
		else{ 	
			#Split										
			print OUT "Wont Merge, $reason\n"; 
			print MERGES "Wont Merge, $reason\n";
			$not_merged_list{$p} = [$c1,$c2];
			}
		next;
	}
	else{ 
		# $c1_dops<70 || $c2_dops<70) && $evalue<-50 to >-20 # then chk with grpsim .. what to do!
		@gs_score = ($c1_dops > $c2_dops) ? &gs_process($c1,$c2) : &gs_process($c2,$c1);
		($signal,$reason)=&scoreanalysis_dops_low(@gs_score);
	
	    #diff range less/more than half the value of same range NEEDS MORE DEMO CHECKS!!!
		if($signal==1){	
			# merge
			#print "Merge\n"; 
			print OUT "Merge\n";
			print MERGES "Merge\n";
			&merge_gs($c1,$c2,$p);
		}
		else{ 										
			#split
			#print "Wont Merge, $reason\n"; 
			print OUT "Wont Merge, $reason\n"; 
			print MERGES "Wont Merge, $reason\n";
			$not_merged_list{$p} = [$c1,$c2];
			}
		next;
	}
}

foreach my $fa (glob("$dir/*.faa")) {
	$fa =~ /\/\w*\/\w*\/\w*\/\w*\/\w*\/.*\/(\d*)\./;
	my $name = $1;
	my $len = `grep -c '>' $fa`;
	if($len==1){
		rename("$dir/$name.$faa", "$dir/$name.$aln");
	}
	else{
		&align($name,$len);
		unlink($fa);
	}
}
close MERGES;

# remove the dir named "filtered"
my $filteddir = "$target_sup_cluster_dir/filtered";
system("rm -r $filteddir");

#Record the time of FunFHMMer Run and end the log
$t = localtime();
print OUT "[$t] #FunFHMMer completed on $superfamily\n";
my $end_run = time();
my $run_time = $end_run - $start_run;
$run_time = $run_time/3600; 
print "$superfamily Done in $run_time hours\n";
$t = localtime();
print OUT "[$t] #Job took $run_time hours\n\n";

close OUT;
########################################## SUBROUTINES ###########################################
	
sub align{
	my $input = $_[0];my $seqnumber = $_[1];
	if($seqnumber> 3000 && $seqnumber < 10000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $dir/$input.$faa -o $dir/$input.$cd -d 100 -c 0.95 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$dir/$input.$faa");
			rename("$dir/$input.$cd","$dir/$input.$faa");
			unlink("$dir/$input.$cd.$clstr");
		}
		elsif($seqnumber > 10000 && $seqnumber < 20000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $dir/$input.$faa -o $dir/$input.$cd -d 100 -c 0.94 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$dir/$input.$faa");
			rename("$dir/$input.$cd","$dir/$input.$faa");
			unlink("$dir/$input.$cd.$clstr");
		}
		elsif($seqnumber > 20000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $dir/$input.$faa -o $dir/$input.$cd -d 100 -c 0.93 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$dir/$input.$faa");
			rename("$dir/$input.$cd","$dir/$input.$faa");
			unlink("$dir/$input.$cd.$clstr");
		}
	if($seqnumber>=2 && $seqnumber<=500){ 
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --localpair --maxiterate 1000 $dir/$input.$faa > $dir/$input.$aln";
	}
	elsif($seqnumber>=501 && $seqnumber<=2000){
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --maxiterate 2 $dir/$input.$faa > $dir/$input.$aln";
	}
	elsif($seqnumber>=2001){
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --retree 1 $dir/$input.$faa > $dir/$input.$aln";
	}
	elsif($seqnumber==1){
		rename ("$dir/$input.$faa","$dir/$input.$aln");
	}
	
	# check whether aln file is generated and if it is empty, then quit 
	my $alnfile = "$dir/$input.$aln";
	if(-e "$alnfile"){
		if(-z "$alnfile"){
			my $t = localtime();
			print OUT "[$t] #ERROR: $alnfile generated is EMPTY: $!";
			#exit;
			#Redo alignment
			print OUT "[$t] #REDOING $alnfile\n";
			&align($input,$seqnumber);
			#&redo_superfamily($superfamily);
		}
	}
	else{
		my $t = localtime();
		print OUT "[$t] #ERROR: $alnfile NOT generated as expected\n";
		#exit;
		#Redo alignment
		print OUT "[$t] #REDOING $alnfile\n";
		&align($input,$seqnumber);
		#&redo_superfamily($superfamily);
	}
}

sub align_while_merging{
	my $input_path = $_[0];my $output_path = $_[1]; 
	#print OUT "#ALIGNING,";
	my $seqs= `grep -c '>' $input_path`;
	if($seqs> 3000 && $seqs < 10000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $input_path -o $input_path.$cd -c 0.95 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$input_path");
			rename("$input_path.$cd","$input_path");
			unlink("$input_path.$cd.$clstr");
		}
		elsif($seqs > 10000 && $seqs < 20000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $input_path -o $input_path.$cd -c 0.94 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$input_path");
			rename("$input_path.$cd","$input_path");
			unlink("$input_path.$cd.$clstr");
		}
		elsif($seqs > 20000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $input_path -o $input_path.$cd -c 0.93 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$input_path");
			rename("$input_path.$cd","$input_path");
			unlink("$input_path.$cd.$clstr");
		}
	if($seqs>=2 && $seqs<=500){ 
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --localpair --maxiterate 1000 $input_path > $output_path";
	}
	elsif($seqs>=501 && $seqs<=2000){
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --maxiterate 2 $input_path > $output_path";
	}
	elsif($seqs>=2001){
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --retree 1 $input_path > $output_path";
	}
	elsif($seqs==1){
		rename ("$input_path","$output_path");
	}
	
	# check whether aln file is generated and if it is empty, then quit 
	if(-e "$output_path"){
		if(-z "$output_path"){
			my $t = localtime();
			print OUT "[$t] #ERROR: $output_path generated is EMPTY\n";
			#exit;
			print OUT "[$t] #REDOING $output_path\n";
			#&redo_superfamily($superfamily);
			&align_while_merging($input_path,$output_path);
		}
	}
	else{
		my $t = localtime();
		print OUT "[$t] #ERROR: $output_path generated is EMPTY\n";
		#exit;
		print OUT "[$t] #REDOING $output_path\n";
		#&redo_superfamily($superfamily);
		&align_while_merging($input_path,$output_path);
	}
}

sub filter_align_while_merging{
	my $input_path = $_[0];my $output_path = $_[1];
	
	#print OUT "#FILTERING,";
	my $seqs= `grep -c '>' $input_path`;
	&filter_mfasta_by_seq_length_mergedfaa($input_path);
	if($seqs> 3000 && $seqs < 10000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $input_path -o $input_path.$cd -d 100 -c 0.95 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$input_path");
			rename("$input_path.$cd","$input_path");
			unlink("$input_path.$cd.$clstr");
		}
		elsif($seqs > 10000 && $seqs < 20000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $input_path -o $input_path.$cd -d 100 -c 0.94 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$input_path");
			rename("$input_path.$cd","$input_path");
			unlink("$input_path.$cd.$clstr");
		}
		elsif($seqs > 20000){
			# make 1.aln -> 1.cd.aln after removing non-redundant sequences
			system("/home/ucbtdas/bin/cdhit-master/cd-hit -i $input_path -o $input_path.$cd -d 100 -c 0.93 -n 5");
			# delete 1.aln, rename 1.cd.aln -> 1.aln, del another cdhit cluster forming file, keep one for adding them back in
			unlink("$input_path");
			rename("$input_path.$cd","$input_path");
			unlink("$input_path.$cd.$clstr");
		}
	if($seqs>=2 && $seqs<=500){ 
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --localpair --maxiterate 1000 $input_path > $output_path";
	}
	elsif($seqs>=501 && $seqs<=2000){
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --maxiterate 2 $input_path > $output_path";
	}
	elsif($seqs>=2001){
		system "/home/ucbtdas/bin/mafft-7.222-without-extensions/scripts/mafft --anysymbol --amino --quiet --retree 1 $input_path > $output_path";
	}
	elsif($seqs==1){
		rename ("$input_path","$output_path");
	}
	
	# check whether aln file is generated and if it is empty, then quit 
	if(-e "$output_path"){
		if(-z "$output_path"){
			my $t = localtime();
			print OUT "[$t] #ERROR: $output_path generated is EMPTY\n";
			#exit;
			print OUT "[$t] #REDOING $output_path\n";
			#&redo_superfamily($superfamily);
			&filter_align_while_merging($input_path,$output_path);
		}
	}
	else{
		my $t = localtime();
		print OUT "[$t] #ERROR: $output_path generated is EMPTY\n";
		#exit;
		print OUT "[$t] #REDOING $output_path\n";
		#&redo_superfamily($superfamily);
		&filter_align_while_merging($input_path,$output_path);
	}
}

sub scorecons{
	my $input = $_[0];my $cluster_dopsfile= "$dir/xtra/$input.$aln.dops";
	system "/usr/local/svn/trunk/bin/scorecons -a $dir/$input.$aln -o $dir/xtra/$input.$aln.scorecons 1> $cluster_dopsfile 2> $codes_dir/funfhmmer_run_dops.temp";
	unlink("$dir/xtra/$input.$aln.scorecons"); # we actually dont need the scorecons file
	#Edit the dops file to replace the file from "DOPS score: xxx" to just "xxx"
	system "perl -p -i -e 's/DOPS score: //g' $cluster_dopsfile";
	
}

sub gs_process{
	my $input1 = $_[0];my $input2 = $_[1]; my @score=(); my $input_cat_num; my $input_aln; my $groupsim_scorefile;
	system "perl $codes_dir/add_cluster_num_in_aln_headers.pl $dir $dir/$input1.$aln $dir/$input2.$aln";
	$input_cat_num="$dir/$input1.$input2";
	$input_aln = "$input_cat_num.aln";
	&align_while_merging($input_cat_num,$input_aln); #GROUPSIM_SCORE FILE
	#print OUT "[$t] #Groupsim start run $input1 $input2,";
	#system "perl $codes_dir/groupsim.rollon_general_dataset.pl $superfamily $input_aln $input1 $input2 $dir $codes_dir";
	&groupsim_rollon_general($input_aln,$input1,$input2);
	#print OUT "[$t] #Groupsim end run $input1 $input2,";
	$groupsim_scorefile="$dir/xtra/$input1.$input2.groupsim.rawscores.processed.quantitate";
	unlink ($input_cat_num); unlink($input_aln); 
	# GET GROUPSIM SCORES from groupsim file!
	open(IN, "<$groupsim_scorefile")
		or die "Can't open file $groupsim_scorefile\n";
	my @lines = <IN>;
	close (IN);
	#my @lines = read_file("$groupsim_scorefile");
	@score = split (/\t/,$lines[2]);
	return @score;
}


sub groupsim_rollon_general{
	my $aln = $_[0];my $grp1 = $_[1]; my $grp2 = $_[2]; 
	unless(-e "$target_sup_cluster_dir/xtra/$grp1.$grp2.groupsim.rawscores.processed.quantitate"){
		system "python $codes_dir/group_sim_sdp.py -c 0.3 -g 0.5 $aln $grp1 $grp2 > $target_sup_cluster_dir/xtra/$grp1.$grp2.groupsim.rawscores";
		if (-z "$target_sup_cluster_dir/xtra/$grp1.$grp2.groupsim.rawscores"){
			system "python $codes_dir/group_sim_sdp_without_cons.py -c 0.3 -g 0.5 $aln $grp1 $grp2 > $target_sup_cluster_dir/xtra/$grp1.$grp2.groupsim.rawscores";
		}
		system "perl $codes_dir/groupsim_rawscores_process_quantitate.pl $target_sup_cluster_dir/xtra/$grp1.$grp2.groupsim.rawscores";
		unlink("$target_sup_cluster_dir/xtra/$grp1.$grp2.groupsim.rawscores");
	}
	#unlink("$sup_dir/xtra/$grp1.$grp2.groupsim.rawscores.processed");
	#if processed >0.8,0.9 signal = merge or signal =not merge
}

sub scoreanalysis{
	my $merge=1;my $case = "default";#default is 1, i.e Merge
	my @array=@_;
	# tot = Total_col.s in MSA
	# a   = <=.3_col.s in MSA 
	# b   = <=.4_col.s in MSA
	# c   = .4~.7_col.s in MSA
	# d   = .7<.8_col.s in MSA
	# e   = .8=1_col.s in MSA
	# f   = None_col.s in MSA
	my $tot = $array[6]; my $a = $array[0]; my $b = $array[1]; 
	my $c = $array[2]; my $d = $array[3]; my $e = $array[4];my $f = $array[5];
	my $ab=$a+$b; my $de=$d+$e; my $abcde=$ab+$c+$de;my $abde=$ab+$de;
	my @scores1 = ($a,$b,$c,$d,$e,$f);my @scores2 = ($ab,$c,$de,$f);
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0 && $f>0){ 	# All NONE 
		$merge=0; $case = "All None";
		return ($merge,$case);
	}
	if($tot > 0){
		my $fper= ($f/$tot)*100;
		if($fper > 70){
			$merge=0; $case = "Majority (>70%) None";
			return ($merge,$case);
		}
	}
	if($tot==0){
		$merge=0; $case = "All zero";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0){  
		$merge=0; $case = "All relevent 0";
		return ($merge,$case);
	}
	my $max1 = max @scores1;
	my $max2 = max @scores2;

	if($max1==$e){ #0.8=0.1 max in @score1
		$merge=0; $case="Max >0.8";
		return ($merge,$case);
	}
	elsif($e>$a){# >0.8 higher than <0.3
		$merge=0; $case="High>0.8";
		return ($merge,$case);
	}
	elsif($max2==$de){ #0.7=0.1 max in @score2
		$merge=0;$case="Max>0.7";
		return ($merge,$case);
	}
	elsif($de>$ab || $de>$a){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	elsif($de>0 && $abde>0){
		my $deper= ($de/$abde)*100;
		if($deper>50){
			$merge=0; $case=">50% 0.7";
			return ($merge,$case);
		}
	}	
	return ($merge,$case);
}

sub scoreanalysis_none_chk_incl{
	my $merge=1;my $case = "default";#default is 1, i.e Merge
	my @array=@_;
	my $tot = $array[6]; my $a = $array[0]; my $b = $array[1]; 
	my $c = $array[2]; my $d = $array[3]; my $e = $array[4];my $f = $array[5];
	my $ab=$a+$b; my $de=$d+$e; my $abcde=$ab+$c+$de;my $abde=$ab+$de;
	my @scores1 = ($a,$b,$c,$d,$e,$f);my @scores2 = ($ab,$c,$de,$f); 
	my @scores1_no_c = ($a,$b,$d,$e,$f);
	if($tot>0){
		my $fper= ($f/$tot)*100;
		if($fper > 70){
			$merge=0; $case = "Majority (>70%) None";
			return ($merge,$case);
		}
	}
	if($tot==0){
		$merge=0; $case = "All zero";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0 && $f>0){ 		#ONLY NONE 
		$merge=0; $case = "All None";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0){  
		$merge=0; $case = "All relevent 0";
		return ($merge,$case);
	}
	my $max1 = max @scores1;
	my $max12 = max @scores1_no_c;
	my $max2 = max @scores2;
	if($max1==$e){ #0.8=0.1 max in @score1
		$merge=0; $case="Max>0.8";
		return ($merge,$case);
	}
	elsif($e>$a){# >0.8 higher than <0.3
		$merge=0; $case="High>0.8";
		return ($merge,$case);
	}
	elsif($max2==$de){ #0.7=0.1 max in @score2
		$merge=0;$case="Max>0.7";
		return ($merge,$case);
	}
	elsif($de>$ab){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	elsif($de>$a){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	elsif($max1==$f){ #none in @score1 & @score2
		if($max2==$f){
			if($f>$abcde){
				$merge=0; $case="Max_none";
				return ($merge,$case);
				}
			}
		}
	if($de>0 && $abde>0){
		my $deper= ($de/$abde)*100;
		if($deper>20){
			$merge=0; $case=">20% 0.7";
			return ($merge,$case);
		}
	}
	return ($merge,$case);
}

sub scoreanalysis_none_chk_incl_strict{
	my $merge=1;my $case = "default";#default is 1, i.e Merge
	my @array=@_;
	my $tot = $array[6]; my $a = $array[0]; my $b = $array[1]; 
	my $c = $array[2]; my $d = $array[3]; my $e = $array[4];my $f = $array[5];
	my $ab=$a+$b; my $de=$d+$e; my $abcde=$ab+$c+$de;my $abde=$ab+$de;
	my @scores1 = ($a,$b,$c,$d,$e,$f);my @scores2 = ($ab,$c,$de,$f); 
	my @scores1_no_c = ($a,$b,$d,$e,$f);
	if($tot>0){
		my $fper= ($f/$tot)*100;
		if($fper > 70){
			$merge=0; $case = "Majority (>70%) None";
			return ($merge,$case);
		}
	}
	if($tot==0){
		$merge=0; $case = "All zero";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0 && $f>0){ #ONLY NONE 
		$merge=0; $case = "All None";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0){  
		$merge=0; $case = "All relevent 0";
		return ($merge,$case);
	}
	my $max1 = max @scores1;
	my $max12 = max @scores1_no_c;
	my $max2 = max @scores2;
	if($max1==$e){ #0.8=0.1 max in @score1
		$merge=0; $case="Max>0.8";
		return ($merge,$case);
	}
	elsif($e>$a){# >0.8 higher than <0.3
		$merge=0; $case="High>0.8";
		return ($merge,$case);
	}
	elsif($max2==$de){ #0.7=0.1 max in @score2
		$merge=0;$case="Max>0.7";
		return ($merge,$case);
	}
	elsif($de>$ab){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	elsif($de>$a){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	elsif($max1==$f){ #none in @score1 & @score2
		if($max2==$f){
			$merge=0; $case="Max_none";
			return ($merge,$case);
		}
	}
	if($de>0 && $abde>0){
		my $deper= ($de/$abde)*100;
		if($deper>20){
			$merge=0; $case=">20% 0.7";
			return ($merge,$case);
		}
	}
	return ($merge,$case);
}

sub scoreanalysis_dops_low{
	my $merge=1;my $case = "default";  #default is 1, i.e Merge
	my @array=@_;
	my $tot = $array[6]; my $a = $array[0]; my $b = $array[1]; 
	my $c = $array[2]; my $d = $array[3]; my $e = $array[4];my $f = $array[5];
	my $ab=$a+$b; my $de=$d+$e; my $abcde=$ab+$c+$de;my $abde=$ab+$de;
	my @scores1 = ($a,$b,$c,$d,$e,$f);my @scores2 = ($ab,$c,$de,$f);
	if($tot>0){
		my $fper= ($f/$tot)*100;
		if($fper > 70){
			$merge=0; $case = "Majority (>70%) None";
			return ($merge,$case);
		}
	}
	if($tot==0){
		$merge=0; $case = "All zero";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0 && $f>0){ 		#ONLY NONE 
		$merge=0; $case = "All None";
		return ($merge,$case);
	}
	if($a==0 && $b==0 && $c==0 && $d==0 && $e==0){  
		$merge=0; $case = "All relevent 0";
		return ($merge,$case);
	}
	my $max1 = max @scores1;
	my $max2 = max @scores2;
	if($max1==$e){ #0.8=0.1 max in @score1
		$merge=0; $case="Max>0.8";
		return ($merge,$case);
	}
	elsif($e>$a){# >0.8 higher than <0.3
		$merge=0; $case="High>0.8";
		return ($merge,$case);
	}
	elsif($max2==$de){ #0.7=0.1 max in @score2
		$merge=0;$case="Max>0.7";
		return ($merge,$case);
	}
	elsif($de>$ab){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	elsif($de>$a){#  >0.7 higher than <0.3/<0.4
		$merge=0; $case="High>0.7";
		return ($merge,$case);
	}
	#added_now
	elsif($max1==$f){ #none in @score1 & @score2
		if($max2==$f){
			if($f>$abcde){
				$merge=0; $case="Max_none";
				return ($merge,$case);
				}
			}
		}
	return ($merge,$case);
}

sub merge_gs { 															
	my $input1 = $_[0];my $input2 = $_[1]; my $output = $_[2]; 
	my $inputfile1 = "$dir/$input1.$aln"; my $outputfile_aln;
	my $inputfile2 = "$dir/$input2.$aln"; my $outputfile = "$dir/$output";
	system "cat $inputfile1 $inputfile2 > $outputfile";
	$outputfile_aln = "$outputfile.$aln";
	&filter_align_while_merging($outputfile,$outputfile_aln);
	unlink("$inputfile1");unlink("$inputfile2");unlink("$outputfile");
}

sub merge_gs_3{
	my $input1 = $_[0];my $input2 = $_[1]; my $input3 = $_[2]; 
	my $output = $_[3]; my $outputfile_aln;
	my $inputfile1 = "$dir/$input1.$aln"; 
	my $inputfile2 = "$dir/$input2.$aln"; my $inputfile3 = "$dir/$input3.$aln"; 
	my $outputfile = "$dir/$output";
	system "cat $inputfile1 $inputfile2 $inputfile3 > $outputfile";
	$outputfile_aln = "$outputfile.$aln";
	&filter_align_while_merging($outputfile,$outputfile_aln);
	unlink("$inputfile1");unlink("$inputfile2"); unlink("$outputfile");unlink("$inputfile3");
}	

sub merge_non_gs {
	my $input1 = $_[0];my $input2 = $_[1]; my $output = $_[2]; 
	my $outputfile = "$dir/$output";
	my $outputfile_aln = "$outputfile.$aln";
	my $inputfile1 = "$dir/$input1.$aln"; 
	my $inputfile2 = "$dir/$input2.$aln"; 
	system "cat $inputfile1 $inputfile2 > $outputfile";
	&filter_align_while_merging($outputfile,$outputfile_aln);
	unlink($outputfile);unlink($inputfile1);unlink($inputfile2);
}

sub filter_mfasta_by_seq_length_startingclusters{
	my $new_dir = "$target_sup_cluster_dir/filtered";
	unless(-e $new_dir) {
		mkdir $new_dir;
	}
	foreach my $faa (glob("$target_sup_cluster_dir/*.faa")) {
		my @field = split("\/",$faa);
		my $y=pop(@field);
		$y =~ s/\.faa//;
		system "perl $codes_dir/filter_fragments_in_fasta.pl $faa > $new_dir/$y.faa"; 
		unlink($faa);
		copy("$new_dir/$y.faa", $faa);
		unlink("$new_dir/$y.faa");
	}
}

sub filter_mfasta_by_seq_length_mergedfaa{
	my $fasta = shift;
	chomp($fasta);
	my $headers = `fgrep -c ">" $fasta`;
	# only filter if the aln has  >10 sequences
	if($headers > 10){
		my $new_dir = "$target_sup_cluster_dir/filtered";
		unless(-e $new_dir) {
			mkdir $new_dir;
		}
		my @field = split("\/",$fasta);
		my $y=pop(@field);
		copy("$fasta", "$new_dir/$y.temp");
		#change the alignment to fasta equivalent
		# create new Bio::SeqIO object    
		#my $in = Bio::SeqIO->new( -file   => "<$new_dir/$y.temp",
					#-format => "fasta");
		my $in_temp = "$new_dir/$y.temp";
		open(F0, "<$in_temp") or die "Can't open file $in_temp\n";
		my $out_temp = "$new_dir/$y.faa";
		open(F1, ">$out_temp") or die "Can't open file $out_temp\n";
		my $c=0;
		while( my $l =<F0>){
			chomp($l);
			if($l=~/^\>/){
				if($c>0){
					print F1 "\n";
				}
				print F1 "$l\n";
				$c++;
				
			}
			else{
				$l=~ s/^\s+//g;
				$l=~ s/-//g;
				print F1 "$l";    
			}
		}
		print F1 "\n";
			# loop through each instance in FASTA file
			
			#while(my $seq = $in->next_seq()){
				#my $id = $seq->id();
				#my $sequence = $seq->seq;
				#$sequence=~ s/^\s+//g;
				#$sequence=~ s/-//g;
				#print F1 ">$id\n$sequence\n";    
			#}
		close F0;
		close F1;
		system "perl $codes_dir/filter_fragments_in_fasta.pl $new_dir/$y.faa > $new_dir/$y.faa_nofrag"; 
		unlink($fasta);
		copy("$new_dir/$y.faa_nofrag", $fasta);
		unlink("$new_dir/$y.faa");
		unlink("$new_dir/$y.faa_nofrag");
		unlink("$new_dir/$y.temp");
		#print "filtered $fasta\n";
		#exit 0;
	}
}

sub redo_superfamily{
	my $sf = shift;
	my $file ="$logdir/$superfamily.redo";
	open(REDO, ">$file") or die "Can't open file $file\n";
	my $t = localtime();
	print REDO "[$t] $superfamily\n";
	close REDO;
}
