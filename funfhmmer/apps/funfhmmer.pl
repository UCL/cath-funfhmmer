#!/usr/bin/env perl
use strict;
use warnings;
use File::Copy;
use FindBin;

# non-core modules
use lib "$FindBin::Bin/../lib/perl5";
use Getopt::Long;
use Path::Tiny;
use File::Basename;
use List::Util qw( min max );
use Funfhmmer::TestIO;
use Funfhmmer::Filter;
use Funfhmmer::Align;
use Funfhmmer::Scorecons;
use Funfhmmer::Groupsim;
use Funfhmmer::Groupsim::GSanalysis;
use Funfhmmer::Merge;
use Data::Dumper;

#####################################################################################################################################################
#
# 							FunFHMMer code by Sayoni
#
# This perl script takes in a folder containing starting clusters of a
# particular CATH Superfamily (generated by GEMMA clustering) and the 
# corresponding clustering trace file to generate FunFHMMer families 
# for the CATH Superfamily
##
#  + Using the 1st quartile Q1 (25% of the Evalues in trace) as the Evalue threshold for auto-merging and Q3 for Evalue relaxing during merging
#  + Added check that if an aln is found empty at any point, the sf tries to redo the alignment
#  + Added checks such that when a superfamily starts running again, it doesnt calculate GS/make alignments that is already done
#  - Removed filter fragments after every merge, so that no coln. is relaxed. - let it be 80% of the threshold
#  + Added modules to the script 
#  + Feeding auto-merge till percentile 10 instead of first quartile of COMPASS E-values
#  
#  
#####################################################################################################################################################

# Check the script inputs with usage and returns script usage if it does not match

my $USAGE = <<"__USAGE__";

Usage: 

    $0 --sup <CATH_superfamily_code> --dir <CATH_superfamily_dir>
    
    Output in <CATH_superfamily_dir>:
    
    1. FunFams (*.aln) in <CATH_superfamily_dir>
    2. sub-folder called 'analysis_data' containing DOPS/SCONS/SDP info in <CATH_superfamily_dir>

__USAGE__

if (! scalar @ARGV) {
	print $USAGE;
	exit;
}

my $wd;
my $superfamily;

GetOptions (    "sup=s"  => \$superfamily,    # string
		"dir=s"  => \$wd,    # string
	    ) or die("Error in command line arguments\n");

die "! ERROR: Input dir '$wd' does not exist"
  unless -e $wd;

#####
# Specify the FunFam and trace directory paths:
#####
our $dir = path("$wd")->absolute;
unless($dir->exists){
	print "ERROR: superfamily tree dir does not exist.\n";
	exit 0;
}
my $treename = $dir->basename;
my $trace_file = $dir->path("tree.trace");
my @tracelines = $trace_file->lines;
# starting clusters list
#my $starting_clusters_file = $dir->path("$superfamily.starting_clusters");
#my @starting_cluster_list = $starting_clusters_file->lines;

#####
# make subfolder "analysis_data" if it does not exist
# this folder would contain the GroupSim (GS) files for all cluster comparisons
#####
our $analysis_subfolder = $dir->path("analysis_data");
unless($analysis_subfolder->exists){
	$analysis_subfolder->mkpath;
}
#####
# NOT USING TL's alignments for now: also move the intermediate cluster alignments from Gemma here. only keeping the staring cluster alignments here
#####
# foreach my $sc90 (glob("$dir/*.faa"))  {
# 	my $sc90_name = path("$sc90")->basename(".faa");
# 	#print "$sc90\t$sc90_name\n";
# 	unless ( grep( /^$sc90_name$/, @starting_cluster_list ) ) {
# 		path("$sc90")->move("$analysis_subfolder/$sc90_name.aln");
# 		path("$sc90")->remove;
# 	}
# }

#####
# Calculate the E-value thresholds to use for this superfamily
#####
my @evalues;
foreach my $traceline (@tracelines){
 	chomp($traceline);
	my ($c1, $c2, $c3, $eval) = split("\t", $traceline);
	push(@evalues, $eval);
}
my $stat = Statistics::Descriptive::Full->new();
$stat->add_data(@evalues);
my $evalthresh_q1 = $stat->quantile(1);
my $evalthresh_percentile10 = $stat->percentile(10);
my $evalthresh_q3 = $stat->quantile(3);

#####
# Check you want to use $evalthresh_gs_start as $evalthresh_q1 or $evalthresh_percentile10
#####
my $evalthresh_gs_start = $evalthresh_percentile10;   

#####
# Start a LOG
#####
my $logfile = $dir->path("$superfamily.$treename.LOG");
open(OUT, ">$logfile") or die "Can't open file $logfile\n";
my $start_run = time();
print OUT "#$superfamily: Processing $treename\n";
print OUT "#$superfamily: Starting FunFHMMer protocol\n";
print OUT "#$superfamily\tEvalue-GS_start:$evalthresh_gs_start\tEvalue-Q3:$evalthresh_q3\n";
print OUT "#$superfamily: Started filtering sequences in starting clusters\n";
Funfhmmer::Filter::filter_mfastas($dir);
print OUT "#$superfamily: Filtering starting clusters completed\n";
# Maintain another MERGELOG for printing out other useful info when necessary
my $mergelog =$dir->path("$superfamily.$treename.mergelog");
open(MERGES, ">$mergelog") or die "Can't open file $mergelog\n";

#####
# Declare variables used in the script
#####
my (@cols, @merges); my %not_merged_list = (); my %not_merged_ignorenextones =();
my ($c1_path,$c2_path,$line); my %cluster_dops=();
my $cl1_dops; my $cl2_dops; my ($cl1,$cl2); my $evalue;
my @gs_score; my @gs_score1; my @gs_score2;my $count=0;

#####
# Split each line in tracefile and store in @cols & store each @col in array of arrays: @merges
#####
open my $TRACE, "<$trace_file";
while (<$TRACE>){
	chomp;
	@cols = split (/\t/, $_); 						
	push @merges, [@cols];				
}
close $TRACE;

#####
# For each pair of clusters analysed in the trace file in order
#####
foreach (@merges){	
	
	my ($c1, $c2, $p, $evalue) = @{$_}; 

	# Get the e-value power number and print current merging cluster info
	
	print OUT "$c1\t$c2\t->\t$p\t$evalue\t";
	print MERGES "$c1\t$c2\t$p\t$evalue\t";
	
	# Check IF any cluster was not produced by previous merging
	if(%not_merged_list){
	 	# IF both clusters not_merged b4
	 	if ($not_merged_list{$c1} && $not_merged_list{$c2}){
			print OUT "Wont merge, None merged b4\n";
			print MERGES "Wont merge, None merged b4\n";
			$not_merged_list{$p} = [$c1,$c2]; 
			$not_merged_ignorenextones{$p} = [$c1,$c2];
			next;
		}
		# IF either of the clusters not_merged b4
		elsif ($not_merged_ignorenextones{$c1} || $not_merged_ignorenextones{$c2}){
			print OUT "Wont merge, None merged b4\n";
			print MERGES "Wont merge, None merged b4\n";
			$not_merged_ignorenextones{$p} = [$c1,$c2];
			next;
		}
		# IF c2 was not_merged b4, find its predessors and check c1 merging with either of them or both
		elsif ($not_merged_list{$c2}) {
			# get c2's 2 unmerged cluster compositions
			my $cl1 = $not_merged_list{$c2}[0]; 				
			my $cl2 = $not_merged_list{$c2}[1];
			#get dops score of MSA using scorecons program
			#IF dops file is empty, assign dops_score=0, else read score from the file
			my $cl1_dops = Funfhmmer::Scorecons::assign_dops_score($cl1,$dir);
			my $cl2_dops = Funfhmmer::Scorecons::assign_dops_score($cl2,$dir);
		
			if ($dir->path("$c1.faa")->exists){
				Funfhmmer::Align::generate_clusterfaa_align($c1,$dir);
			}
			my $c1_dops = Funfhmmer::Scorecons::assign_dops_score($c1,$dir);
		
			# Get Groupsim_scores for both merging and compare and then decide
			# Use Cluster with higher dops as ref. or 1st group always!
			my @gs_score1 = ($cl1_dops > $c1_dops) ? Funfhmmer::Groupsim::gs_process($cl1,$c1,$dir) : Funfhmmer::Groupsim::gs_process($c1,$cl1,$dir);
			my @gs_score2 = ($cl2_dops > $c1_dops) ? Funfhmmer::Groupsim::gs_process($cl2,$c1,$dir) : Funfhmmer::Groupsim::gs_process($c1,$cl2,$dir);
		
			my ($signal1, $reason1)= Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score1,$cl1_dops,$c1_dops,$evalue,$evalthresh_gs_start,$evalthresh_q3);
			my ($signal2, $reason2)= Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score2,$cl2_dops,$c1_dops,$evalue,$evalthresh_gs_start,$evalthresh_q3);
			 
			if($signal1 == 1 && $signal2 == 1){ 
				# Merge c1 & cl1 & cl2
				print OUT "Merge, $c1 & $cl1 , $cl2 --> $p\n";
				print MERGES "Merge\t$c1\t$cl1\t$cl2\t->\t$p\n";
				Funfhmmer::Merge::merge_gs_3($c1,$cl1,$cl2,$p,$dir);
				next;
			}	
			elsif($signal1 == 1 && $signal2 == 0){ 
				# Merge c1 &cl1
				print OUT "Merge, $c1 & $cl1 --> $p\n";
				print MERGES "Merge\t$c1\t$cl1\t->\t$p\n";
				Funfhmmer::Merge::merge_cluster_pair($c1,$cl1,$p,$dir); 
				next;
			}
			elsif($signal1 == 0 && $signal2 == 1){ 
				# Merge c1 &cl2
				print OUT "Merge, $c1 & $cl2 --> $p\n";
				print MERGES "Merge\t$c1\t$cl2\t->\t$p\n";
				Funfhmmer::Merge::merge_cluster_pair($c1,$cl2,$p,$dir);
				next;
			}
			else{ 
				# dont Merge c1 & cl1 & cl2
				print OUT "Wont merge $c1 & $cl1,$cl2\n";
				print MERGES "Wont merge $c1\t$cl1\t$cl2\n";
				$not_merged_list{$p} = [$c1,$cl1,$cl2]; 
				next;
			}
		}
		# IF c1 was not_merged b4, find its predessors and check c2 merging with either of them or both
		elsif ($not_merged_list{$c1}) { 						
		
			# get c1's 2 unmerged cluster compositions
			my $cl1 = $not_merged_list{$c1}[0]; 				
			my $cl2 = $not_merged_list{$c1}[1];
			my $cl1_dops = Funfhmmer::Scorecons::assign_dops_score($cl1,$dir); 
			my $cl2_dops = Funfhmmer::Scorecons::assign_dops_score($cl2,$dir); 
			if ($dir->path("$c2.faa")->exists){ 
				Funfhmmer::Align::generate_clusterfaa_align($c2,$dir);
			}
			my $c2_dops = Funfhmmer::Scorecons::assign_dops_score($c2,$dir); 

			# Get score files for both merging and compare and then decide 		
			# Use Cluster with higher dops as ref. or 1st group always!
			my @gs_score1 = ($cl1_dops > $c2_dops) ? Funfhmmer::Groupsim::gs_process($cl1,$c2,$dir) : Funfhmmer::Groupsim::gs_process($c2,$cl1,$dir);
			my @gs_score2 = ($cl2_dops > $c2_dops) ? Funfhmmer::Groupsim::gs_process($cl2,$c2,$dir) : Funfhmmer::Groupsim::gs_process($c2,$cl2,$dir);
			
			my ($signal1, $reason1)= Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score1,$cl1_dops,$c2_dops,$evalue,$evalthresh_gs_start,$evalthresh_q3);
			my ($signal2, $reason2)= Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score2,$cl2_dops,$c2_dops,$evalue,$evalthresh_gs_start,$evalthresh_q3);
			 
			if($signal1 == 1 && $signal2 == 1){ 
				# Merge c2 & cl1 & cl2
				print OUT "Merge, $c2 & $cl1 , $cl2 --> $p\n";
				print MERGES "Merge\t$c2\t$cl1\t$cl2\t->\t$p\n";
				Funfhmmer::Merge::merge_gs_3($c2,$cl1,$cl2,$p,$dir);
				next;
				}	
			elsif($signal1 == 1 && $signal2 == 0){ 
				# Merge c2 &cl1
				print OUT "Merge, $c2 & $cl1 --> $p\n";
				print MERGES "Merge\t$c2\t$cl1\t->\t$p\n";
				Funfhmmer::Merge::merge_cluster_pair($c2,$cl1,$p,$dir); 
				next;
				}
			elsif($signal1 == 0 && $signal2 == 1){ 
				# Merge c2 &cl2
				print OUT "Merge, $c2 & $cl2 --> $p\n";
				print MERGES "Merge\t$c2\t$cl2\t->\t$p\n";
				Funfhmmer::Merge::merge_cluster_pair($c2,$cl2,$p,$dir);
				next;
				}
			else{ 
				# dont Merge c2 & cl1 & cl2
				print OUT "Wont merge $c2 & $cl1,$cl2\n";
				print MERGES "Wont merge $c2\t$cl1\t$cl2\n";
				$not_merged_list{$p} = [$c2,$cl1,$cl2]; 
				next;
				}
		}
	}
	# If the parents of the current clusters are not in the above lists, then proceed as the following:
		if($dir->path("$c1.faa")->exists){
			Funfhmmer::Align::generate_clusterfaa_align($c1,$dir);
		}
		if($dir->path("$c2.faa")->exists){
			Funfhmmer::Align::generate_clusterfaa_align($c2,$dir);
		}
		my $c1_dops = Funfhmmer::Scorecons::assign_dops_score($c1,$dir);
		my $c2_dops = Funfhmmer::Scorecons::assign_dops_score($c2,$dir); 
		
		# Merge as usual from lowest evalue to evaluethresh (1st quartile of evalue range)
		if($evalue < $evalthresh_gs_start){ 
			print OUT "Merge, e < $evalthresh_gs_start\n";
			print MERGES "Merge, e < $evalthresh_gs_start\n";
			Funfhmmer::Merge::merge_cluster_pair($c1,$c2,$p,$dir);
			next;
		}
		else{
			# For higher Evalues, we need to calculate additional things - mda_score and 70 of the clusters: 
			# use dops of the clusters to check MSA of clusters are informative enough - choose GS score analysis method accordingly
			# Evalue from $evalthresh_gs_start to $evalthresh_q3
			print OUT "GS ->  ";
			print MERGES "GS ->  ";
			my @gs_score = ($c1_dops > $c2_dops) ? Funfhmmer::Groupsim::gs_process($c1,$c2,$dir) : Funfhmmer::Groupsim::gs_process($c2,$c1,$dir);
			my ($signal, $reason)= Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score,$c1_dops,$c2_dops,$evalue,$evalthresh_gs_start,$evalthresh_q3);
			# Analyze score signals 
			if($signal==1){
				# Merge
				print OUT "Merge\n";
				print MERGES "Merge\n";
				Funfhmmer::Merge::merge_cluster_pair($c1,$c2,$p,$dir);
			}
			else{
				# Split
				print OUT "Wont Merge, $reason\n";
				print MERGES "Wont Merge, $reason\n";
				$not_merged_list{$p} = [$c1,$c2];
			}
			next;
		}
}

foreach my $fa (glob("$dir/*.faa")) {
	my $fa_name = path("$fa")->basename(".faa");
	my $aln = $dir->path("$fa_name.aln");
	Funfhmmer::Align::generate_catcluster_align($fa,$aln);
}

my @output_errors = Funfhmmer::TestIO::check_output($superfamily, $dir);

if($output_errors[0] > 0){
	print OUT "#ERROR: Superfamily folder has $output_errors[0] FAA files\n";
	print "ERROR: Superfamily folder has $output_errors[0] FAA files\n";
}
if($output_errors[1] == 0){
	print OUT "#ERROR: Superfamily folder has $output_errors[1] ALN files\n";
	print "ERROR: Superfamily folder has $output_errors[1] ALN files\n";
}
elsif($output_errors[2] > 0){
	print OUT "#ERROR: Superfamily folder has $output_errors[2] empty ALN files\n";
	print "ERROR: Superfamily folder has $output_errors[2] empty ALN files\n";
}

close MERGES;

#####
# remove the dir named "filtered"
#####
system("rm -r $dir/filtered");

#####
# tar the analysis data folder and remove it to make space
#####
#system("tar -zcf $dir/$superfamily.$treename.analysis_data.tar.gz $dir/analysis_data/*");
#$analysis_subfolder->remove;

#####	
#Record the time of FunFHMMer Run and end the log
#####
print OUT "#FunFHMMer completed on $superfamily\n";
my $end_run = time();
my $run_time = $end_run - $start_run;
$run_time = $run_time/3600; 
print "$superfamily Done in $run_time hours\n";
print OUT "#Job took $run_time hours\n\n";

close OUT;