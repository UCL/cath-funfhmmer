#!/usr/bin/env perl
use strict;
use warnings;

#core modules
use File::Copy;
use Data::Dumper;
use File::Basename;
use List::Util qw( min max );
use FindBin;

# non-core modules
use Getopt::Long;
use Path::Tiny;
use Log::Dispatch;
use DateTime;
use Math::Round;

# Funfhmmer modules
use lib "$FindBin::Bin/../lib";
use Funfhmmer::Align;
use Funfhmmer::Scorecons;
use Funfhmmer::Groupsim;
use Funfhmmer::Groupsim::GSanalysis;
use Funfhmmer::Merge;

#####################################################################################################################################################
#
# 							FunFHMMer code by Sayoni
#
# This perl script takes in a folder containing starting clusters of a
# particular CATH Superfamily (generated by GEMMA clustering) and the
# corresponding clustering trace file to generate FunFHMMer families
# for the CATH Superfamily
#
#
#####################################################################################################################################################

# Check the script inputs with usage and returns script usage if it does not match

my $USAGE = <<"__USAGE__";

Usage:

    $0 --sup <CATH_superfamily_code> --dir <CATH_superfamily_dir> --groupsim_matrix <id> --automerge_loweval <0/1> 

    Options:
    --groupsim_matrix	    id		Identity matrix
                            mc		Mclachlan matrix (Chemical similarity)

    --automerge_loweval		1	    1st quartile of trace E-value range     # ideal for first funfam generation
               		        0	    Do not use any E-value threshold        # ideal for iterative funfam generation
    
    Input in <CATH_superfamily_dir>:

    tree.trace
    funfam_alignments/working_*.aln             # copied starting cluster alignments
    merge_node_alignments/merge_node_*.aln

    Output in <CATH_superfamily_dir>:

    1. <CATH_superfamily_dir>/funfam_alignments/*.aln
    2. <CATH_superfamily_dir>/funfam_alignments/analysis_data/* (containing DOPS/SCONS/SDP info)

__USAGE__

if (! scalar @ARGV) {
	print $USAGE;
	exit;
}

my ($wd, $superfamily, $groupsim_matrix, $automerge_loweval);

GetOptions (    "sup=s"             => \$superfamily,    # string
                "dir=s"             => \$wd,    # string
                "groupsim_matrix=s" 	=> \$groupsim_matrix,
                "automerge_loweval=i"      => \$automerge_loweval,
            )
            or die("Error in command line arguments\n");

die "! ERROR: Input dir '$wd' does not exist\n"
    unless -e $wd;

die "! ERROR: groupsim_matrix (input given:'$groupsim_matrix') should be either 'id' or 'mc'\n"
    unless($groupsim_matrix eq "id" || $groupsim_matrix eq "mc");
    
die "! ERROR: automerge_loweval (input given:'$automerge_loweval') should be '1' (default SF-specific E-value will be used) or '0' for using GS for all merges at all Evalues\n"
    unless($automerge_loweval == 0 || $automerge_loweval == 1);
    
my $start_run = time();

#####
# Specify the FunFam and trace directory paths:
#####

our $dir = path("$wd")->absolute;
our $funfam_dir = $dir->path("funfam_alignments");
our $merge_nodes_aln_dir = $dir->path("merge_node_alignments");

# make a sub-folder that would contain the GroupSim (GS) files for all cluster comparisons
our $analysis_subfolder = $funfam_dir->path("analysis_data");
unless($analysis_subfolder->exists){	
    $analysis_subfolder->mkpath;
}

print "dir: $dir\nsuperfamily: $superfamily\ngroupsim_matrix: $groupsim_matrix\n";

#####
# Calculate the E-value thresholds to use for this superfamily
#####

my $trace_file = $dir->path("tree.trace");
my @tracelines = $trace_file->lines;

my @evalues;
foreach my $traceline (@tracelines){
 	chomp($traceline);
	my ($node1, $node2, $c3, $eval) = split("\t", $traceline);
	push(@evalues, $eval);
}

my $stat = Statistics::Descriptive::Full->new();
$stat->add_data(@evalues);
my $evalthresh_q1 = $stat->percentile(10);
my $evalthresh_q3 = $stat->percentile(75);

my $evalthresh_gs_start=$evalthresh_q1;

#####
# #NOTE
# Check you want to use $evalthresh_gs_start as percentile20 or percentile10
# This is the percentile of E-values that would be merged automatically without using FunFHMMer
# Important for getting informative clusters that FunFHMMer can analyse
# Higher percentile values can lead to functionally impure clusters being merged
#####

	
my $auto_merge_low_evalues = $automerge_loweval;

#####
# Start a LOG
#####

my $LOG_LEVEL= 'info' ;
my $LOG = Log::Dispatch->new(
  outputs => [
    [ 'Screen', min_level => $LOG_LEVEL, stderr => 0, newline => 0 ],
    [ 'Screen', min_level => 'warning', stderr => 1, newline => 1 ],
    [ 'File', min_level => 'debug', filename => "$dir/$superfamily.LOG" ],
  ],
  callbacks => sub {
    my %p = @_;
    my @lines = split (/\n/, $p{message});
    my $msg = join( "", map { sprintf( "%s [%s] %s\n", DateTime->now()->datetime(), $p{level}, $_ || '' ) } @lines );
    return $msg;
  },
);


$LOG->info( "# Processing $superfamily" );
$LOG->info( "# Starting FunFHMMer protocol" );
$LOG->info( "# Groupsim-matrix used: $groupsim_matrix" );
$LOG->info( "# Evalue-GS_start:$evalthresh_gs_start\tEvalue-Q3:$evalthresh_q3" );
$LOG->info( "# Auto_merge_low_evalues: $auto_merge_low_evalues" );
$LOG->info( "#" );

#####
# Declare variables used in the script
#####

our %not_merged_list = ();
our %not_merged_ignorenextones =();

my $count=0;
my %cluster_dops=();
my ( @cols, @merges, @gs_score, @gs_score1, @gs_score2 );
my ( $cl1, $cl2, $node1_path, $node2_path, $line, $cl1_dops, $cl2_dops, $evalue);

# Counter to check whether any merges different from gemma tract has been made
our $tree_modified_merge =0;

#####
# Split each line in tracefile and store in @cols & store each @col in array of arrays: @merges
#####

open my $TRACE, "<$trace_file";
while (<$TRACE>){
	chomp;
	@cols = split (/\t/, $_);
	push @merges, [@cols];
}
close $TRACE;


#####
# For each pair of clusters analysed in the trace file in order
#####

foreach (@merges){

	my ($node1, $node2, $merge_node, $evalue) = @{$_};

	my $node1_aln = $funfam_dir->path("$node1.aln");
	my $node2_aln = $funfam_dir->path("$node2.aln");

	if($node1_aln->exists && $node2_aln->exists){

		# Merge pairs of nodes as usual from lowest E-value to E-value threshold (i.e. till the 1st quartile of E-value range of the trace file)

		if($evalue < $evalthresh_gs_start && $auto_merge_low_evalues == 1){

			Funfhmmer::Merge::merge_use_gemma_alns($node1, $node2, $merge_node, $dir);

			$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tlow_Evalue\tmerge-E<$evalthresh_gs_start" );

			next;
		}
		else{

			# For higher Evalues (from $evalthresh_gs_start to $evalthresh_q3), we need to use Groupsim. Use DOPS of the clusters to check MSA of clusters are informative enough - choose GS score analysis method accordingly

			my $node1_dops = Funfhmmer::Scorecons::assign_dops_score($node1, $funfam_dir);
			my $node2_dops = Funfhmmer::Scorecons::assign_dops_score($node2, $funfam_dir);


			# The node aln with higher dops is taken as the first alignment as this seemed to have an affect on the GroupSim Groupsim_scores in an analysis on TPP superfamily. This might be due to the fact that the first aln is used as a reference is some way. Need to investigate whether this is true for all superfamilies

			my @gs_score = ($node1_dops > $node2_dops) ? Funfhmmer::Groupsim::gs_process($node1, $node2, $funfam_dir, $groupsim_matrix) : Funfhmmer::Groupsim::gs_process($node2, $node1, $funfam_dir, $groupsim_matrix);

			my ($signal, $reason) = Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score, $node1_dops, $node2_dops, $evalue, $evalthresh_gs_start, $evalthresh_q3);

#print "$node1 ($node1_dops), $node2 ($node2_dops)";####

			if($signal==1){

				# Merge

				Funfhmmer::Merge::merge_cluster_pair($node1, $node2, $merge_node, $dir);

				$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tGS\tmerge" );

			}
			else{
				# Keep nodes separate - Cut point

				$not_merged_list{$merge_node} = [$node1, $node2];

				$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tGS\tnomerge-$reason" );
			}

			$auto_merge_low_evalues = 0;

			next;
		}
	}
	else{

		# Check IF any node does not exists i.e. it was not produced by previous merging based on FunFHMMer rules

		if(%not_merged_list){

			my $check_both_node_alns = &check_if_child_nodes_exist($node1, $node2, $merge_node, $evalue);

			if($check_both_node_alns == 0){

				next;
			}
			else{

				if($not_merged_list{$node1}){

					$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tabsent-node1\tnomerge-absent-node1" );

					&check_if_one_child_node_does_not_exist($node2, $node1, $merge_node, $evalue);

					next;
				}
				elsif($not_merged_list{$node2}){

					$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tabsent-node2\tnomerge-absent-node2" );

					&check_if_one_child_node_does_not_exist($node1, $node2, $merge_node, $evalue);

					next;
				}
			}

			$auto_merge_low_evalues = 0;

		}

	}

	die "! ERROR: Node '$merge_node' aln file does not exist\n"
        if -z $merge_node;
}

#####
# Tar the analysis data folder and remove it to make space
#####

system("tar -zcf $dir/$superfamily.analysis_data.tar.gz -C $dir/funfam_alignments ./analysis_data/");
#system("rm -r $analysis_subfolder");

#####
# Generate the list of generated funfam_alignments
# Generate a file containing the list of starting clusters for each FunFam
#####

# Generate a hash containing sequence headers for starting clusters
my $sc_dir = "$dir/starting_cluster_alignments";

my %sc_seq_hash=();

foreach my $sc (glob("$sc_dir/*.aln")) {
  my @sc_headers = `fgrep ">" $sc`;
  my $sc_name = basename($sc, ".aln");
  foreach my $header (@sc_headers){
    chomp($header);
    $header=~ s/\>//g;
    $sc_seq_hash{$header} = $sc_name;

  }
}

#print Dumper(\%sc_seq_hash);

my $funfam_list = "$dir/$superfamily.funfams.list";
open(FUNFAM_LIST, ">$funfam_list") or die "Can't open file $funfam_list\n";
print FUNFAM_LIST "#FUNFAMS\n";

my $funfam_sc_list = "$dir/$superfamily.funfams.starting_cluster.list";
open(FUNFAM_SC, ">$funfam_sc_list") or die "Can't open file $funfam_sc_list\n";
print FUNFAM_SC "#GROUPS OF STARTING_CLUSTERS THAT MAKEUP FUNFAMS\n";

my $funfam_sc_seq_list = "$dir/$superfamily.funfams.starting_cluster.md5.list";
open(FUNFAM_SC_MD5_LIST, ">$funfam_sc_seq_list") or die "Can't open file $funfam_sc_seq_list\n";

print FUNFAM_SC_MD5_LIST "#FUNFAM\tSEQ_MD5\tSTARTING_CLUSTER\n";

foreach my $funfam_file (glob("$funfam_dir/*.aln")) {

  chomp($funfam_file);
  my $funfam_name = basename($funfam_file, ".aln");
  my @ffheaders = `fgrep ">" $funfam_file`;

  my %clusters = ();

  foreach my $header (@ffheaders){

    chomp($header);
    $header=~ s/\>//g;
    my $sc =  $sc_seq_hash{$header};


    if($sc){

	$clusters{$sc}=1;

    }

    print FUNFAM_SC_MD5_LIST "$funfam_name\t$header\t$sc\n";
  }

  foreach my $cl (sort keys %clusters){

    print FUNFAM_SC "$cl ";

  }

  print FUNFAM_SC "\n";
  print FUNFAM_LIST "$funfam_name\n";

}
close FUNFAM_LIST;
close FUNFAM_SC;
close FUNFAM_SC_MD5_LIST;

$LOG->info( "#" );
$LOG->info( "# Generated FunFam list for $superfamily");


#####
# Record the time of FunFHMMer Run and end the log
#####

$LOG->info( "#" );
$LOG->info( "# FunFHMMer completed on $superfamily");

my $end_run = time();

my $run_time = $end_run - $start_run;
$run_time = $run_time/3600;
$run_time = nearest(0.0001, $run_time);
print "$superfamily Done in $run_time hours\n";

$LOG->info( "# JOBTIME: $run_time hours" );

sub check_if_child_nodes_exist{

	my ($node2, $node1, $merge_node, $evalue) = @_;

	my $node_alns_state = 1;

	# IF both nodes were not merged before
	if ($not_merged_list{$node1} && $not_merged_list{$node2}){

		$not_merged_list{$merge_node} = [$node1, $node2];
		$not_merged_ignorenextones{$merge_node} = [$node1, $node2];
		$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tGS\tnomerge-none_merged_before" );

		$node_alns_state = 0;

	}
	# IF either of the clusters not_merged before
	elsif ($not_merged_ignorenextones{$node1} || $not_merged_ignorenextones{$node2}){

		$not_merged_ignorenextones{$merge_node} = [$node1, $node2];
		$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tGS\tnomerge-none_merged_before" );

		$node_alns_state = 0;

	}

	return $node_alns_state;
}

#####
# Subroutines
#####

sub check_if_one_child_node_does_not_exist{

	my ($node1, $node2, $merge_node, $evalue) = @_;

	if ($not_merged_list{$node2}) {

		# get subnodes of node2 unmerged cluster compositions
		my $cl1 = $not_merged_list{$node2}[0];
		my $cl2 = $not_merged_list{$node2}[1];

		#get dops score of MSA using scorecons program
		my $cl1_dops = Funfhmmer::Scorecons::assign_dops_score($cl1, $funfam_dir);
		my $cl2_dops = Funfhmmer::Scorecons::assign_dops_score($cl2, $funfam_dir);
		my $node1_dops = Funfhmmer::Scorecons::assign_dops_score($node1, $funfam_dir);

		# Get Groupsim_scores for both merging and compare and then decide
		# Use Cluster with higher dops as ref. or 1st group always!

		my @gs_score1 = ($cl1_dops > $node1_dops) ? Funfhmmer::Groupsim::gs_process($cl1, $node1, $funfam_dir, $groupsim_matrix) : Funfhmmer::Groupsim::gs_process($node1, $cl1, $funfam_dir, $groupsim_matrix);

		my @gs_score2 = ($cl2_dops > $node1_dops) ? Funfhmmer::Groupsim::gs_process($cl2, $node1, $funfam_dir, $groupsim_matrix) : Funfhmmer::Groupsim::gs_process($node1, $cl2, $funfam_dir, $groupsim_matrix);

		my ($signal1, $reason1) = Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score1, $cl1_dops, $node1_dops, $evalue, $evalthresh_gs_start, $evalthresh_q3);

		my ($signal2, $reason2) = Funfhmmer::Groupsim::GSanalysis::scoreanalysis(\@gs_score2, $cl2_dops, $node1_dops, $evalue, $evalthresh_gs_start, $evalthresh_q3);

#print "$node1 ($node1_dops), $cl1 ($cl1_dops), $cl2 ($cl2_dops)";####
		if($signal1 == 1 && $signal2 == 1 && $node1_dops >= 70){

			# Merge c1 & cl1 & cl2
			Funfhmmer::Merge::merge_gs_3($node1, $cl1, $cl2, $merge_node, $dir);

			$LOG->info( "$node1\t$node2\t$merge_node\t$evalue\tGS\tmerge-$node1,$cl1,$cl2=$merge_node ($reason1,$reason2)" );

		}
		elsif($signal1 == 1 && $signal2 == 0){

			# Merge c1 &cl1
			Funfhmmer::Merge::merge_cluster_pair($node1, $cl1, $merge_node, $dir);

			$LOG->info( "$node1\t$cl1\t$merge_node\t$evalue\tGS\tmerge-$node1,$cl1=$merge_node ($reason1,$reason2)" );

		}
		elsif($signal1 == 0 && $signal2 == 1){

			# Merge c1 &cl2
			Funfhmmer::Merge::merge_cluster_pair($node1, $cl2, $merge_node, $dir);

			$LOG->info( "$node1\t$cl2\t$merge_node\t$evalue\tGS\tmerge-$node1,$cl2=$merge_node ($reason1,$reason2)" );

		}
		else{
			# dont Merge c1 & cl1 & cl2
			$not_merged_list{$merge_node} = [$node1, $cl1, $cl2];

			$LOG->info( "$node1\t$cl2\t$merge_node\t$evalue\tGS\tnomerge-$node1,$cl1,$cl2 ($reason1,$reason2)" );

		}
	}
}
